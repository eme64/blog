---
title: "JDK26: Auto Vectorization and Aliasing"
date: 2026-01-14
---

Aliasing is one of the biggest obstacles to vectorization and auto vectorization in particular.
As we will see further below, it is also relevant for uses of the Vector API.

Aliasing is about overlap of memory regions, which can lead to problems when we try to reorder memory accesses
for vectorization. But let's take it step by step and start with an example:

```java
for (int i = init; i < limit; i++) {
    b[i] = a[i];
}
```

To vectorize the loop above, we first unroll the loop, and then reorder the loads and stores,
and pack them into vectorized loads and stores:

<img width="700" alt="image" src="https://github.com/user-attachments/assets/2976fcb8-347c-4dee-9a6e-abe5bddaac9c" />

But how can we prove that the reordering is ok, i.e. that we can move all the loads to the top and the
stores to the bottom?
If `a` and `b` refer to different arrays, we know that the loads are not affected by the stores,
and thus it is ok to move the loads to the top.
If `a = b`, then we need to look at the indices of the array accesses.
We can see that the accesses of iteration `i` go only to element `i`, and accesses of iteration `i+1` go only to element `i+1`.
This means that operations of different iterations cannot interfere with each other, and thus we can
move all the loads to the top.

**When the Compiler cannot prove that there is no Aliasing**

Now let's look at another example where reordering would be problematic:

```java
for (int i = init; i < limit; i++) {
    b[i] = a[i + offset];
}
```

If the two references `a` and `b` point to different arrays, we can vectorize without any concerns.
But the compiler may not be able to prove that `a` and `b` do not alias, i.e. point to the same array.
For example, we may have the following scenario at runtime, where `a = b` and `offset = -1`,
in which case each iteration loads a value from the last element and copies it to the current one:

<img width="400" alt="image" src="https://github.com/user-attachments/assets/8e42c11d-b3bf-49d4-b76c-7c1e72f11220" />

As visualized below, this means that the first element is copied forward in every iteration, so there is a dependency
between the iterations. The implication is that the iterations are decidedly not parallel, and so naive vectorizaton
will lead to wrong results, as we can see in the lower half of the graphic below:

<img width="700" alt="image" src="https://github.com/user-attachments/assets/08d980d5-4b6d-40e8-acca-8a2314848519" />

So even if it is very rare that `a = b` and the `offset` is such that vectorization leads to wrong results,
the compiler cannot just ignore that (faint) possibility - the generated code needs to be always correct!

**Aliasing and Vector API**

TODO

**Links**

In JDK26 I implemented the aliasing runtime check in the auto vectorizer, allowing new loop shapes to
be auto vectorized
([JDK-8324751](https://github.com/openjdk/jdk/pull/24278)).

YouTube video that covers pointers and aliasing:
[Section on Pointers and Aliasing in JVMLS 2025 Talk](https://www.youtube.com/watch?v=UVsevEdYSwI&t=1134s)

**Please leave a comment below**

To edit/delete a comment: click on the `date` above your comment, e.g. `just now` or `5 minutes ago`.
This takes you to the GitHub issue page associated with this blog post. Find your comment, and edit/delete it
by clicking the three dots `...` on the top right.

<script src="https://utteranc.es/client.js"
        repo="eme64/blog"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
